# MySQL的锁
* 全局锁
* 表级锁
* 行级锁

## 全局锁
* 全局锁主要应用于全局逻辑备份，全局锁就意味着全表处于只读的状态。
* 加上全局锁会导致其他业务停滞，所以可以使用在可重复读的隔离级别下备份数据库，即开启备份数据库的时候，开启事务，创建read veiw。InnoDB是支持可重复读的隔离级别的，MyISAM这种不支持，就需要上全局锁。

## 表级锁
* 表锁
* 元数据锁（MDL）
* 意向锁
* AUTO-INC锁

### 表锁
* 表锁会对所有的线程（包括自己）限制读写操作

### 元数据锁
* 对数据进行（CRUD）的时候，加上MDL读锁
* 对数据进行结构变更的时候，加上MDL读锁
* 读读不冲突，读写冲突

### 意向锁
* InnoDB对记录加共享锁之前，需要在表级上加意向共享锁
* InnoDB对记录加独占锁之前，需要在表级上加意向独占锁
* <font color = red>意向锁的主要作用是判断表中是否有记录被加锁</font>

### ATUTO-INC锁
* 使用AUTO-INCREAMENT修饰某一个字段，在插入数据的时候，可以不指定该字段的数据，数据库会自动给该字段赋一个自增的值。
  
## 行级锁
* record lock 记录锁
* gap lock 间隙锁
* next-key lock：记录锁+间隙锁

# MySQL加锁
* mysql 对于记录加锁的基本单位是next-key lock（前开后闭）
* 间隙锁（前开后开）

## 加锁的情况
* 唯一索引等值查询（会退化为记录锁）
* 唯一索引范围查询（会退化为范围锁）
* 非唯一索引等值查询（next-key lock + 间隙锁）
* 非唯一索引范围查询（间隙锁）

## update 没有加索引  会导致锁全表
update语句的where条件没有加索引，就会进行全表扫面，于是就会对所有的记录加上next-key lock。
* 解决方法：sql_safe_update = 1
  
# MySQL死锁了怎么办
* 在插入数据的时候，需要做幂等校验，就是查询当前记录是否存在，如果不存在，再进行插入的操作。

## 死锁的发生
* ![](picture/死锁示例.png)

* 对于可重复读的隔离级别，会对记录加上next-key lock，防止其他事务插入数据，解决幻读的问题。

* 间隙锁和间隙锁是兼容的，所以两个读取的事务都会对表加上间隙锁<font color = red>（两个事务加上包含共同间隙的隙锁）</font>。

* 在进行插入操作的时候需要先获取到插入意向锁，需要等待对象的间隙锁释放，于是造成了循环等待。<font color = red>（自身可以在自己的间隙锁上面插入数据）</font>

* <font color = red>间隙锁本质上是用于阻止其他事务在该间隙内插入新记录，而自身事务是允许在该间隙内插入数据的</font>

## 插入意向锁的生成时间：
每一条插入记录的时候，都需要看该记录是被已经被加了间隙锁，如果被加了间隙锁，则该插入语句会被阻塞，同时生成一个插入意向锁。

## insert语句怎么加行级锁
### 记录之间加了间隙锁
* 每条插入语句的时候，会看是否加了间隙锁，如果加了间隙锁，则insert语句阻塞，并生成插入意向锁。
### 遇到唯一键冲突

## 如何避免死锁
* 死锁的四个条件
  * 互斥
  * 占有且等待
  * 不可剥夺
  * 循环等待

### 打破循环等待
* 设置事务等待锁超时时间，默认50s
* 开启主动死锁检测，让死锁链中某一条事务回滚。


<font color = red></font>
<font color = red></font>
<font color = red></font>
<font color = red></font>
<font color = red></font>
